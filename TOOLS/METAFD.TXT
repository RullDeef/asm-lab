










                              AFDPror

              Полноэкранный профессиональный отладчик
                  (руководство по использованию)

       Методическое руководство для выполнения лабораторного
  практикума, практических занятий и курсового проектирования по
   курсам  "Основы вычислительной техники_ и _Микропроцессоры и
        микроконтроллеры_ для студентов 2,3,4 курсов АВТФ.
              (Направление 551500 - Приборостроение)









                     Новосибирск  НГТУ 1998 г.









Методическое руководство содержит описание и методику использования
                        отладчика AFDPror.



    Составил канд. техн. наук, доцент Г.Г.Матушкин.
    Рецензенты: доцент, к.т.н. А.В.Якименко,
                           ст.преподаватель Е.Д.Баран.


             Работа подготовлена кафедрой систем сбора
                        и обработки данных





    Новосибирский государственный

    технический университет, 1998г.



                             ВВЕДЕНИЕ

    Полноэкранный профессиональный отладчик AFDPror обеспечивает интерактивный
доступ   ко  всем  основным  ресурсам  ЭВМ,  основанным  на   базе
процессоров  семейства  80Х86, работающих  в  реальном  режиме,  и
позволяет весьма эффективно отлаживать пользовательские программы,
написанные   на   языке  Ассемблера.  Отладчик  дает   возможность
контролировать   и   модифицировать  состояние   всех   программно
доступных   регистров  процессора  и  ячеек  памяти   в   адресном
пространстве  обьемом  1 Мбайт. В связи с  этим  отладчик  AFDPror
может  быть  весьма  эффективно использован при  изучении  базовой
архитектуры  микропроцессоров семейства  88Х86,  путем  проведения
лабораторного практикума в компьютерных и терминальных классах.
    Предлагаемое учебное пособие предназначено для освоения работы с данным
отладчиком с целью изучения системы команд Ассемблера, закрепления
знаний  по  базовой  архитектурным  особенностям  микропроцессоров
a%,%)ab"   80Х86,  а также приобретения навыков отладки  программ,
написанных  на  языке  Ассемблера,  используемого  в  персональных
компьютерах IBM PC и совместимых с ними.
    AFDPror  представляет  собой  EXE  -  файл,  загружаемый   для
выполнения  операционной  системой  DOS.  После  запуска   AFDPror
резервирует память, начиная с последнего используемого адреса, для
загрузки отлаживаемой программы пользователя.
    Управление отлаживаемой программе пользователя передается либо при
выполнении   соответсвующей   директивы,   либо   после    нажатия
функциональной клавиши. Если не включена трассировка, отлаживаемая
программа пользователя выполняется в реальном масштабе времени, до
тех  пор,  пока управление не возвращается в отладчик.  Выполнение
отлаживаемой  программы  прерывается либо по  достижении  заданных
пользователем  контрольных точек с остановом, либо вручную,  путем
одновременного нажатия клавиш Ctrl/Esc.
    Отладчик AFDPror может быть установлен (инсталлирован) в любой
персональной ЭВМ IBM PC и совмещеных с ними, с процессором не ниже
i  80286  и  операционной системой MS-DOS версий  3.1  и  выше.  В
AFDPror могут быть загружены для отладки файлы типа .EXE и .COM.
    Отладчик дает возможность вводить в отлаживаемую программу до 8
контрольных   точек,  которые  позволяют  при  их   достижении   и
одновременном  выполнении  при  этом  некоторых  заданных  условий
осущестлять  ряд , также заранее заданных операций  (действий).  К
таким  операциям,  например, относятся: подсчет числа  прохождений
данной контрольной точки при выполнении программы, останов,  сброс
счетчика проходов указанной контрольной точки и.т.п.
    Совокупность заданных контрольных точек совместно с их атрибутами может
быть  сохранена  в виде файла во внешней памяти и  использована  в
дальнейшем.
    След трассировки отображает: выполненные в процессе трассировки
команды, текущее содержимое всех программно доступных регистров, а
также содержимое 8 байт стековой памяти, начиная с вершины стека.
    Отладчик может быть переведен в резидентный режим работы,  что
позволяет  получить  управление даже, если отлаживаемая  программа
зависла,  установив  флаг  запрещения  прерывания,  и  система  не
воспринимает ввод с клавиатуры.
    Запуск  оладчика  осуществляется вызовом в оперативную  память
персональной ЭВМ файла _AFDPror.exe_ и последующего нажатия  любой
клавиши клавиатуры.




      Раздел I.  Исходные поля отображения на экране дисплея.

    После  инициирования  отладчика на экране  дисплея  появляются
следующие поля отображения (см. Рис 1):
    1. Поле программно доступных регистров и вершины стека;
    2. Поле дизассемблирования или поле отлаживаемой программы;
    3. Два независимых поля дампов оперативной памяти ( 1 и 2);
    4. Поле подсказки назначения функциональных клавиш.
    5. Поле командной строки (CMD);

    1. Поле программно доступных регистров и вершины стека.
    Поле программно доступных регистров процессора и вершины стека
расположено  в  верхней  части экрана дисплея.В  нем  расположены:
восемь регистров общего назначения AX, BX, CX, DX, BP, SP, SI, DI;
четыре  сегментных  регистра CS, DS, ES, SS; регистр  -  указатель
команд  IP  и  регистр  флагов Flags,  которые  входят  в  базовую
архитектуру   процессоров  семейства  80X86.  В   этом   же   поле
отображаются  содержимое  четырех,  16  разрядных  ячеек   памяти,
начиная с ячейки, адресуемой указателем стека,регистром SP.
      Кроме  этого,  в  этом поле отображаются два вспомогательных
регистра самого отладчика HS и FS, которые специально введены  для
удобства пользователя при отладке программ.
    Рассмотрим все эти регистры подробнее.

                    Регистры общего назначения

    Группа регистров общего назначения (РОН) - AX, BX, CX, DX, SP, BP,
SI, и DI образует собой как бы ячейки некоторого сверхоперативного
регистрового  запоминающего устройства.Регистры  AX,  BX,  CX,  DX
обычно  называют регистрами данных, а регистры SP, BP,  SI,  DI  -
регистрами   указателями  адресов.  Различаются  они   не   только
преимущественным  назначением их содержимого  но  и  возможностями
обращения.  Так,  если регистры SP, BP, SI, DI могут  адресоваться
только как 16 разрядные регистры, то регистры AX, BX, CX, DX могут
быть  адресованы и как  16 разрядные регистры и, раздельно, как  8
`  '`o$-k% регистры AH и AL, BH и BL, CH и CL, DH и DL. При  этом,
регистры  H  образуют старшие байты соответствующих  16  разрядных
регистров, а регистры L - их младшие байты.
    Однако,  кроме указанных общих черт, каждый из этих  регистров
общего назначения имеет свою специфику, которая выражается в  том,
что  некоторые  команды, при их выполнении, по  используют  только
вполне определенные из этих регистров


    Регистр AX (Accummulator register) (AL - при выполнении операций с 8
разрядными   кодами).Этот  регистр  носит  название   регистра   -
аккумулятора.  Он  используется для хранения  исходных  операндов,
промежуточного и окончательного результатов и, поэтому,  участвует
в  большинстве  операций   процессора. Команды,  управляющие  этим
регистром  компактны и занимают в памяти мало места. Специфичность
его  использования заключается, например в том, что при выполнении
операции   умножения,  множимое  всегда  содержится   в   регистре
аккумуляторе  AX  (  или AL  при однобайтном умножении.  Результат
произведения,   при  однобайтном  умножении  всегда  располагается
полностью в регистре AX, а при 16 разрядных операндах, в  регистре
AX  всегда располагается младшие два байта произведения,  (старшие
два  байта  произведения,  при  этом,  всегда  будут  размещены  в
регистре DX).

    При делении однобайтных чисел, байт делимого всегда располагается
в  регистре AL, а результат разместится следующим образом: в AL  -
частное,  в  AH  - остаток. При делении двухбайтных  чисел,  в  AX
всегда  содержаться младшие 16 бит 32 разрядного делимого (старшие
16  бит  делимого всегда размещаются в регистре DX). При  этом  16
разрядов  частного также обязательно фиксируются  в  регистре  AX,
(остаток от деления формируется в регистре DX).

    Регистр AX(AL) также всегда является источником или получателем
данных   при   операциях   обмена  информацией   с   периферийными
устройствами,   а  также,  операциях  загрузки  (сохранения)   или
сканирования элементов цепочечных (строковых) данных.

    Регистр BX (Base register)  также называют еще и вазовым регистром,
поскольку,  при  базовой  адресации, он содержит  начальный  адрес
некоторой  области памяти (базовый адрес), который,  суммируясь  с
адресным  смещением, формирует эффективный адрес требуемой  ячейки
/  ,ob(.  Следовательно, одна и таже машинная  команда,  используя
регистр  BX, может адресоваться к различным областям памяти  путем
простого изменения содержимого базового регистра BX.

    Регистр CX (Counter register) - регистр счетчик. Специфика его
заключается  в том, что его содержимое используется  по  умолчанию
пои выполнении целого ряда команд:

    -  при   организации циклических операций, как заданное  число
циклов;

    -  при  реализации  сдвиговых операций,  как  требуемое  число
разрядов,  на  которое должно быть сдвинуто содержимое  указанного
регистра или ячейки памяти;

    -  при  операциях состроками (цепочками) байт  или  слов,  как
число элементов обрабатываемой строки.

    Регистр DX ( Data register) - регистр данных. Специфика регистра DX
состоит в том, что:

    -  при  операциях умножения целых двухбайтовых  чисел,  в  нем
фиксируется 16 старших разрядов произведения (младшие 16  разрядов
располагаются в регистре аккумуляторе AX);

    -  при  операциях  деления целых чисел, в него  во-первых,  до
операции  заносятся  старшие  16  разрядов  делимого  (младшие  16
разрядов  находятся в регистре AX), а во-вторых, после  выполнении
операции,  в  нем  фиксируется остаток от  деления  (частное  -  в
регистре AX);

    -   при   обмене   информацией  с  периферийными  устройствами
(операциях ввода/вывода), при их числе,превышающем 256, регистр DX
используется для организации их косвенной адресации. Для  этого  в
него   предварительно  заносится  номер  требуемого  периферийного
устройства.

    В связи с этой его спецификой регистр DX часто называют вторым
аккумулятором для храниения промежуточных данных и результатов.

    Указательные регистры SP и BP, кроме возможности использования их в
качестве   регистров   общего   назначения   также   имеют    свое
специфическое назначение.



    -



    Регистр SP (Stack Pointer) - указатель стека. В нем хранится адрес
ячейки  памяти  ,  где  находится вершина стека,  т.е.  последний,
занесенный  в  стековую  память байт.  Этот  регистр  используется
автоматически  (подразумеваемая адресация) при обращении  к  стеку
либо  при  исполнении  команд  типа PUSH  и  POP,  для  временного
запоминания  кодов и данных в процессе выполнения  программ,  либо
при  организации обработки прерывания и обращения к подпрограммам,
при   которых   также   требуется  временное  хранение   некоторой
информации.
    Регистр  BP  (Base  Pointer) - указатель базы.  Этот  регистр,
используемый    как   базовый,   дает   возможность   сформировать
эффективный  адрес ячейки памяти, находящейся внутри  стека,  т.е.
дает  возможность  обращаться  к  информации,  размещенной  внутри
области  стековой  памяти непосредственно,  а  не  последовательно
через указатель стека SP.

    Указательные регистры адреса SI и DI носят  название индексных регистров
и,  кроме возможности использования их в качестве регистров общего
назначения,   предназначены для указания индексного  смещения  при
формировании адресов.
    Регистр SI (Source Index) - индексный регистр адреса источника.
    Регистр DI (Destination Index) - индексный регистр адреса назначения.
Первое  их  специфическое назначение заключается в  том,  что  они
используются  в  качестве указателя адреса  байта  или  слова  при
исполнении  таких строковых (цепочечных) команд  как: LOADS  (Load
String)  -  загрузить строку;  CMPS (Compare  String)  -  сравнить
строку;   MOVS  (Move String) - переслать строку.  При  выполнении
строковых  операций, регистры SI и DI инкрементируются (при  флаге
DF=0)  или  декрементируются (при флаге DF=1), что позволяет,  при
использовании    префиксов   типа   REP,    осуществлять    режимы
инкрементации или декрементации регистров SI и DI до тех пор, пока
заданное заранее содержимое регистра счетчика CX не станет  равным
0.
    Во  вторых,  эти  регистры используются  для  организации  так
называемой  базово-индексной адресации,  когда  эффективный  адрес
формируется  как  сумма  содержимого  индексного  (SI  или  DI)  с
a.$%`&(,k,  регистра BX или BP и, с добавлением  в  ряде  случаев,
некоторой константы  - смещения.

                        Сегментные регистры.

    Все  возможные  адреса оперативной памяти ЭВМ  с  процессорами
семейства  80Х86, работающих в реальном режиме, образуют  адресное
пространство  обьемом  1  Мегабайт. В этом  адресном  пространстве
выделяются 4 области (сегмента) - CS, DS, ES и SS, обьемом  по  64
Кбайта  каждая.  Положение этих сегментов в адресном  пространстве
задается   указанием  их  начальных  адресов   в   соответствующих
регистрах,  которые носят название сегментных  регистров.   Каждый
сегмент,  в  некотором  смысле,  специализируется  под  размещение
соответствующих   программных   ресурсов.   Так,   кодовый,    или
программный, сегмент CS (Code Segment) хранит в себе все  основные
программы, необходимые при обработке информации. В сегмент  данных
DS   (Data  Segment)  обычно  записываются  все  исходные  данные,
подлежащие   обработке,   а   также  промежуточные   иокончатеьные
результаты.  Вспомогательный сегмент данных, или экстрасегмент  ES
(Extra  Segment)  также  используется под хранение  обрабатываемых
данных  ,  и  является необходимым при обработке  строк.  Наконец,
стековый сегмент SS (Stack Segment) используется, в основном,  как
область стековой памяти.
    Указанные сегменты могут располагаться в любых местах ядресного
пространства  не  пересекаясь или пересекаясь с  дискретностью  не
меньшей, чем 16 байт. Они могут также располагаться все в одном  и
том  же  месте адресного пространства (в случае одинаковых  кодов,
занесенных в сегментные регистры), образуя одно общее используемое
адресное пространство обьемом в 64 Кбайта.
    Такое сегментирование адресного пространства позволяет разнести
каманды и данные по отдельным областям адресного пространства, что
увеличивает  надежность обработки информации, а также реализовать,
в  большинстве  случаев обращение к общему адресному  пространству
обьемом 1 Мегабайт с помощью 16 разрядных адресов. Это обьясняется
тем,   что,   выбрав   места  размещения  сегментов   в   адресном
пространстве  (  указав  их  начальные  адреса  в  соответствующих
сегментных  регистрах),  адресация ячеек  памяти  в  этих  текущих
сегментах  может осуществлятся указанием 16 разрядного смещения  в
этих  сегментах (так называемого эффективного адреса). И только  в
a+cg   %,  когда  адресуемый  операнд  располагается  вне  данного
сегмента,  т.е.  в  другом сегменте, необходимо  указывать  полный
адрес - <сегмент>:<смещение>, где в качестве <сегмента>указывается
начальный  адрес  требуемого сегмента, а в качестве  <смещения>  -
эффективный адрес операнда.
    Функции регистров общего назначения в арифметических и логических
операциях  сегментные регистры выполнять не могут,  поскольку  они
используются   для   идентификации  текущих  сегментов   адресного
пространства.

    Регистр  CS (Code Segment) - регистр кодового или программного
сегмента.
    В регистре CS хранится начальный адрес кодового сегмента, т.е.
области  памяти,  в которой размещена текущая команда  исполняемой
программы.
    Регистр DS (Data Segment) - регистр сегмента данных.
    В  регистре  DS  хранится начальный адрес  основного  сегмента
данных в адресном пространстве, т.е. области памяти, в которой,  в
общем  случае,  хранятся программно изменяемые  таблицы  данных  и
константы.   Все  эффективные адреса операндов и  обычных  команд,
формируемые с помощью регистров BX,SI или DI определяются  в  этом
сегменте,  являясь  смещением  относительно  регистра  DS.  Адреса
операндов  в командах строковых (цепочечных) операций, формируемые
спомощью  индексного регистра SI,  также находятся в  сегменте  DS
(т.е.   выполняются  также  относительно  содержимого  сегментного
регистра DS).
    Регистр ES (Extra Segment) - регистр экстра-сегмента, дополнительного
сегмента данных.В данном регистре хранится начальный адрес области
памяти    (сегмента),   обычно   используемого   для   запоминания
промежуточных данных, т.е. в качестве рабочей зоны памяти.   Кроме
того,  все  эффективные адреса операндов при  работе  с  командами
строковых операций, формируемых с помощью индексного регистра  DI,
являются  смещениями к содержимому регистра ES, т.е.  также  будут
размещатся в сегменте ES.
    Регистр SS (Stack Segment) - регистр сегмента стека. В этом регистре
хранится  начальный адрес сегмента, который отводится под стековую
память. Эта область памяти, как уже упоминалось выше, используется
для   временного  хранения  данных  и  адресов  при   обслуживании
прерываний  или  обращения к процедурам, а  также  при  исполнении
*.,  -$  типа  PUSH  и POP. Обращение к сегменту  стековой  памяти
происходит  также  в случае косвенной адресации  с  использованием
указательного базового регистра BP.

                     Регистр указателя команд.
    Регистр  IP (Instruction Pointer) - регистр указателя  команд,
выполняет роль счетчика команд. Его содержимое представляет  собой
адрес  следующей  команды,  подлежащей  выполнению.  Оно  является
смещением в кодовом сегменте CS.

                         Регистр флагов F.

    Регистр F (Flags) - регистр флагов (признаков). Отдельные биты этого
регистра  (флаги) представляют информацию о результате выполненной
в  арифметико-логическом устройстве операции, а некоторые из  них,
устанавливаемые    пользователем,   могут   управлять    процессом
обработки.
    На экране дисплея состояние этого 16 разрядного регистра флагов
отображается двояким образом:
    - в виде четырехзначного шестнадцатеричного числа;
    - в виде линейки состояний отдельных его разрядов (флагов) :
CF, PF, AF,  ZF, SF, OF, IF, DF.
    Сделано это потому, что не все разряды регистра Flags являются
флагами.  Некоторые разряды постоянно представлены 0 или  1  и  не
несут  никакой  информации  о состоянии  процессора  и  результате
выполненной операции.
    Регистр Flags содержит флаги двух типов:
    - флаги состояния, которые отображают признаки результата
операции после исполнения очередной команды и используются, в
основном, при выполнении тех или иных команд условных переходов;
    -  флаги  управления, которые устанавливаются пользователем  и
служат для управления процессом обработки информации процессором.
    Флаг  считается  установленным,  если  соответствующий  разряд
находится в состоянии 1, и сброшенным, если соответствующий разряд
находится в состоянии 0.
    Рассмотрим назначение отдельных флагов регистра Flags подробнее.

    а) Флаги состояния.

    CF (Carry Flag) - флаг переноса. Устанавливается аппаратно при
возникновении  переноса из старшего разряда арифметико-логического
устройсва  при осуществлении арифметических и сдвиговых  операций.
Кроме   того,   флаг  CF  может  устанавливаться  и   сбрасываться
программно.  Состояние  флага  CF  используется  процессором   при
осущестлении  арифметических операций для определения переполнения
разрядной сетки , переноса и заема при действиях с многоразрядными
целыми  числами,  а также для определения знака результата.  Кроме
того,  флаг  CF используется при выполнении сдвиговых операций,  а
также при выполнении операций условного перехода.
    PF  (Parity  Flag) - флаг паритета. Устанавливается  аппаратно
при  четном числе единиц в коде младшего байта результата операции
в    арифметико-логическом   устройстве.   Процессором   флаг   PF
используется:
    - при проверке работоспособности памяти ЭВМ с помощью
диагностических тестов;
    - для определения ошибок при передаче данных.
    AF   (Auxiliary   Flag)  -  флаг  вспомогательного   переноса.
Устанавливается  аппаратно  при наличии  переноса  из  третьего  в
четвертый   бит   младшего  байта  результата  при   осуществлении
арифметических операций ( т.е.  при переносе из первой  во  вторую
тетраду  этого  байта).  Процессором используется  при  выполнении
арифметических  операций  над  двоично-десятичными  числами,   как
признак необходимости коррекции результата.
    ZF  (Zero  Flag)  - флаг нулевого результата.  Устанавливается
аппаратно  при  равенстве нулю результата операций с  байтами  или
словами.  Процессором используется при исполнении команд  условных
переходов   по   нулевому  результату,   а  также  равенству   или
неравенству операндов.
    SF  (Sign  Flag) - флаг знака. Устанавливается  аппаратно  при
появлении  1  в старшем разряде результата выполнения  операции  в
арифметико-логическом  устройстве и,  следовательно  характеризует
знак  результата при арифметических операциях с целыми числами  со
знаком.  Используется процессором при исполнении  команд  условных
переходов по знаку результата.
    OF  (Overflow  Flag)  - флаг переполнения.  Устанавливается  в
случае    переполнения   разрядной   сетки    при    осуществлении
арифметических  операций с  числами со знаком,  поскольку  в  этом
случае,  установление в 1 флага CF еще не может служить  признаком
/%`%/.+-%-(o разрядной сетки. Флаг переполнения OF устанавливается
аппаратно и является логической функцией неравнозначности переноса
в  старший (знаковый) разряд результата и переноса из его старшего
разряда.  Процессором  этот флаг используется  обычно  для  вызова
процедур  обработки прерывания по переполнению с  помощью  команды
INTO (Interrupt on Overflow).

    б) Флаги управления.

    IF  (Interrupt  Flag)  - флаг разрешения прерывания.  Флаг  IF
устанавливается  и  сбрасывается программно  самим  пользователем.
Установкой  этого  флага (IF=1) пользователь разрешает  процессору
реагировать   на   поступление   запросов   внешних    маскируемых
прерываний,  поступающих  от внешних  источников  по  входу  INTR.
Сбросом  его (IF=0)  пользователь запрещает процессору реагировать
на   них.   Запрет  этот  не  касается  немаскируемых  прерываний,
поступающих на вход NMI и прерываний программных. Установка  этого
флага  осуществляется  командой STI (Set  Interrupt),  а  сброс  -
командой CLI (Clear Interrupt).
    DF    (Direction   Flag)   -   флаг   направления.   Флаг   DF
устанавливается  и сбрасывается тоже программно с  помощью  команд
STD  (Set  Direction)  и  CLD  (Clear Direction),  соответственно.
Применяется  этот  флаг преимущественно при  использовании  команд
обработки  цепочек  (строк), таких как  CMPS  (Compare  String)  -
сравнение строки, LODS (Load String) - загрузка строки, MOVS (Move
String)  -  пересылка  строки, SCAS (Scan String)  -  сканирование
строки  и STOS ( Save String) - сохранение  (запоминание)  строки.
Когда  флаг DF установлен (DF=0), эти команды автодекрементируются
и,  следовательно, обработка строк происходит по элементам (байтам
или  словам)  от старших адресов к  младшим. При этом,  содержимое
индексных  регистров  SI  и  DI, которые  при  этом  используются,
уменьшаются  с  дискретностью 1 или  2  (в  зависимости  от  того,
являются ли элементы строк байтами или словами).
    Когда же флаг DF сброшен (DF=0), эти команды инкрементируются, т.е.
обработка  строк  происходит по элементам, от  младших  адресов  к
старшим.  Аналогично, в зависимости от типа используемых строковых
команд  (операции  с  байтами  или словами)  содержимое  индексных
регистров SI и DI увеличиваются с дискретностью 1 или 2.

                               Стек.

    В  поле регистров отображаются также 4 последних, занесенных в
стек  слова  (8 байт). Слово вершины стека отображается  в  строке
"Stack   +0".  Таким  образом в ней представлено  содержимое  двух
байт,  младший из которых адресуется содержимым регистра указателя
стека  SP.  В  строках "+2", "+4", "+6"  отображены  16  разрядные
слова, содержащиеся в ячейках памяти по адресам, большими адреса в
регистре указателя стека, соответственно, на 2, на 4 и на 6.

    2. Поле отлаживаемой программы (поле дизассемблирования).

    Слева в центральной части экрана расположено поле отлаживаемой
программы  или  поле  дизассемблирования с отображением  состояния
ячеек кодового сегмента памяти. На этом поле отображаются:
    -  адреса  ячеек  кодового  сегмента  памяти,  соответствующие
адресам первых байт кодов команд;
    - сами коды команд;
    - дизассемблированные выражения этих кодов команд.
    В   поле  отображается  не  более  9  команд  любого  формата.
Перемещение   этого   программного  дампа   по   всему   адресному
пространству  кодового сегмента осуществляется при помощи  клавиш-
стрелок  (построчно),  а  также клавиш "Page  Up"  и  "Page  Down"
(постранично).  Выделенная  маркерной полосой  команда  называется
текущей  командой, которая выполняется первой при задании директив
запуска  программы на исполнения в непрерывном режиме  -  "G"  или
"GC"  ,  или при нажатии функциональной клавиши пошагового  режима
исполнения F1.
    Над  выделенной строкой обычно располагается еще одна  строка,
строка предыдущей команды, которая может перекрываться сообщениями
отладчика о состоянии системы и сообщениями об ошибках, когда  они
появляются.
    Если маркерная полоса выделяет команду, которая адресует операнд
косвенно,  то,  для  удобства  отладки,  на  границе  между  полем
отлаживаемой  программы  и полем командной  строки  (CMD),  справа
высвечивается содержимое этой, косвенно адресуемой, ячейки памяти,
т.е. сам операнд.
    Перед загрузкой отлаживаемой программы состояние ячеек памяти может
быть  произвольным  и, следовательно таким же  произвольным  будут
  aa%,!+%`-k% выражения на экране в этом поле. После загрузки .EXE
или  .COM файла отлаживаемой программы она расположится начиная  с
указанного  адреса  и  затем  автоматически  дизассемблируется   в
соответствии с ее командами. Поэтому, при последующих  просмотрах,
или  запусках  программы на исполнение , следует следить  за  тем,
чтобы  указывать адреса именно первых байт тех команд,  с  которых
желательно начать просмотр или запуск программы.


    3. Поля дампов памяти .

    Справа  от  поля дизассемблирования размещено  поле  дампа  1,
отображающего расположенное в 10 строках  содержимое  80  байтовых
ячеек  памяти  начиная  с  указанного адреса.  Задание  начального
адреса  дампа может быть осуществлено при помощи директивы "M1"  (
см.   описание   поля   командной  строки),  или   непосредственно
корректируя адрес в поле дампа, переведя на него курсор при помощи
функциональных клавиш F7...F10, а затем используя клавиши стрелки.
Возможна  и  коррекция  самого содержимого ячеек  памяти,  которая
осуществляется после перевода курсора на выбранный  байт  также  с
помощью  клавиш-стрелок.Последовательное  перемещение  окна  дампа
памяти по адресному пространству заданного сегмента осуществляется
как  клавишами-стрелками (построчно), так и клавишами "Page Up"  и
"Page Down"(постранично).
    Ниже поля дизассемблирования и поля дампа 1 размещено поле дампа
2.  Функционально дамп 2 идентичен дампу 1, имея тот же  обьем  80
байт (правда, расположенный в пяти строках). Однако, в отличие  от
дампа  1,  он  сопровождается таблицей  представления  содержимого
ячеек памяти этого дампа в кодах ASCII в правой части поля.
    Задание начального адреса дампа2 может быть осуществлено с помощью
директивы  "M2" (см. описание поля командной строки),  либо  также
непосредственно  корректируя адрес в поле  дампа,  устанавливая  в
место коррекции курсор, так как описана эта операция для дампа  1.
Осуществление  коррекции содержимого ячеек  памяти  в  дампе  2  и
перемещение  его  по  адресному  пространству  заданного  сегмента
осуществляется так же аналогичным образом.

    4. Поле подсказки  назначения функциональных клавиш.
    В этом поле, размещенном в самой нижней части экрана сокращенно
.!.'-  g%-k назначения функциональных клавиш, которые позволяют  в
ряде  случаев  эффективно  управлять  отладчиком  не  прибегая   к
директивам  командной строки. Более подробно, описание  назначения
функциональных  клавиш  изложено в разделе 2  _Управление  работой
отладчика_.

    5. Поле командной строки (CMD).
    В  поле  командной  строки отображаются  команды  (директивы),
задаваемые   пользователем  при  управлении   работой   отладчика.
Описание  директив и их использование изложены  подробно  также  в
разделе 2 _Управление работой отладчика_.

    Раздел II.  Управление работой отладчика.

    Основное управление работой отладчика осуществляется при помощи
управляющих  команд (директив) отладчика, задаваемых  в  командной
строке.  Наиболее  же  часто встречаемые операции,  реализуются  с
помощью нажатия функциональных клавиш.

    1. Назначение функциональных клавиш.
    Прежде  всего  этом  заметим, что все  функциональные  клавиши
поддерживаются   как  клавиши  с  возможностью  автоповтора.   Это
означает,что  когда  клавиша нажата и не  отпускается,  вызываемая
функция будет повторяться в темпе, соответсвующем примерно 10  раз
в секунду.
    Рассмотрим подробно назначение каждой задействованной функциональной
клавиши.
    F1 (Step) - пошаговый режим.  С помощью функциональной клавиши
F1   осуществляется  пошаговый  (покомандный)   режим   выполнения
отлаживаемой  программы.  При каждом нажатии  клавиши  исполняется
одна  команда,  та,  которая  в  данный  момент  выделена  в  поле
дизассемблирования маркерной полосой.
    F2  (ProcStep) - процедурный шаг. При использовании клавиши F2
осуществляется  такой пошаговый режим работы,  когда  имеющиеся  в
программе   процедуры  автоматически  выполняются  за   один   шаг
(фактически  в  непрерывном режиме работы). Это позволяет  в  ряде
случаев   существенно  упростить  и  ускорить  отладку  программы,
особенно при заведомо правильных процедурах. Следует отметить, что
при   включенной  трассировке,  след  выполнения  этих   процедур,
"k/.+-o%,ke в непрерывном режиме, все равно остается (см. описание
задания трассировки и просмотр ее следа).
    F3  (Retrieve)  - Восстановлене. Последовательность  директив,
задаваемых  пользователем  в  командной  строке,  запоминается   в
специальном  стековом  буфере. Нажатием  клавиши  F3  пользователь
может  восстанавливать эти директивы (вызывать из буферной  памяти
снова в командную строку) в обратной последовательности.
    F4(Help  ON) - помощь. Нажатие этой клавиши вызывает на  экран
дисплея,  на место дампа 2, краткие комментарии ко всем директивам
отладчика, которые может задавать пользователь в командной строке.
Смена  на  экране директив с их пояснениями определяется  нажатием
клавиш "Page Down" (в прямой алфавитной последовательности перечня
директив) и "Page Up" ( в обратной алфавитной последовательности).
Заметим,  что  если  в  командную строку  уже  занесена  некоторая
директива,  то  нажатие  клавиши F4 вызывает  на  экран  сразу  же
пояснение   именно этой директивы , и оно не изменяется  пока  эта
директива будет оставаться записанной в командную строку.
    F5  (BRK  Menu) - вход в меню задания контрольных  точек.  При
нажатии клавиши F5 на экране отображается меню задания контрольных
точек в виде таблицы, в которой пользователь может задать адреса 8-
ми контрольных точек, а также их атрибуты. К атрибутам контрольных
точек относятся:
    -   логические   условия,  при  которых   срабатывает   данная
контрольная  точка,  т.е. может осуществиться  некоторое  заданное
действие (операция);
    - число проходов данной контрольной точки при исполнении
отлаживаемой программы,  при котором возможно ее срабатывание.
    - характер самого заданного действия.
    Подробно способы задания контрольных точек и их атрибутов изложены в
разделе III - _Работа с контрольными точками_.
    F7,   F8,  F9,  F10  -  клавиши,  с  помощью  которых   курсор
переводится с одного поля экрана дисплея на другое. При этом:
    -  F7  (up) и F8 (dn) - являются клавишами перевода курсора  с
одного   поля   экрана   на  другое  в  вертикальном   направлении
(соответственно, снизу ввех и сверху вниз по кругу );
    -  F9  (le)  и F10 (ri) - являются клавишами перевода  курсора
между полями в горизонтальном направлении (соответственно, влево и
вправо по кругу).
      Перевод  курсора из любого поля непосредственно в  командную
ab`.*c   может  быть  осуществлен путем нажатия  клавиши  "Enter".
Перевод  курсора  внутри  полей осуществляется  с  помощью  клавиш
стрелок.


    2.  Назначение директив командной строки.

    В данном параграфе описываются все директивы отладчика AFDPror,
которые  можно  вводить  через  командную  строку.  Все  директивы
описываются  в  алфавитном  порядке.  Большинство  директив  может
вводиться  в виде одного или двух символов как прописными,  так  и
строчными  буквами. Только директива Quit имеет  4  символа  и  их
нужно  вводить  полностью, что позволяет  избежать  нежелательного
завершения   программы.  Необязательные  символы  при  обозначении
директивы,  а  также  ее  необязательные  параметры,  заключены  в
фигурные скобки.
    Перемещение курсора в комадной строке возможно только вправо или влево:
на  одну  позицию - с помощью клавиш-стрелок; в конец строки  -  с
помощью клавиши _End_; в начало строки - с помощью клавиши _Home_.
    Фактический ввод команды происходит после нажатия клавиши _Enter_.

    ? {%} = expresion.
    Директива _?_ определяет проведение арифметических операций над
целочисленными  значениями  операндов, входящих  в  арифметическое
выражение    (expresion).    Результат    операции    отображается
непосредственно под полем командной строки в виде:
                  Result = <результат операции>.
    Следует учитывать, что последовательность выполнения  арифметических
операций    в    заданном   в   заданном   выражении    происходит
последовательно  слева направо, независимо от типа  арифметических
операций, т.е. без учета их приоритета.
    Этой директивой удобно пользоваться, например, при вычислении или
модификации адресов, а также в случае необходимости преобразования
шестнадцатеричных  кодов  чисел  в  десятичные  или  наоборот.  По
умолчанию,   все   операнды,  как   и  результат   подразумеваются
представленными   в  шестнадцатеричной  системе  счисления.   Если
операнд представляется в десятичной системе, перед ним должен быть
поставлен  символ  _%_. При необходимости получения  результата  в
десятичной системе счисления, символ _%_ ставится через пробел  за
a(,".+., директивы _?_.
    Вместо непосредственных операндов, в арифметическом выражении могут
указываться  имена  регистров.  В этом  случае,  операндами  будут
считаться сдержимое этих регистров.
    Примеры:  ? = 07AF+BX+SI
                        ?  % = 1A6E
                        ? = %3965

    A {addr} - (Assembler).
    Данная  директива  является директивой  входа  в  Ассемблер  и
используется  при  разработке пользователем ассемблерных  программ
или  некоторых  их  фрагментов, а также при модификации  отдельных
команд отлаживаемой программы.
    После  ввода этой директивы отладчик AFDPror переходит в режим
ассемблирования.  Курсор переходит на поле  дизассемблирования,  в
позицию  ассемблерных  выражений в выделенной  маркерной  полосой,
строке  дизассемблированного кода. Символы при  этом  отображаются
тем  же  цветом, что и во всех входных полях AFDPror. Введенное  с
помощью  клавиатуры ассемблерное выражение новой команды программы
пользователя  вводится  и  ассемблируется  после  нажатия  клавиши
_Enter_.  При  этом маркерная полоса переходит на адрес  следующей
свободной ячейки памяти.
    Заметим,  что заменяемая команда может иметь длину  в  байтах,
отличную  от  длины новой команды. В этом случае, отображаемые  на
экране последующие команды, могут изменить свое значение.
    Начальный адрес ввода команд программы в кодовый сегмент может
задаваться  пользователем, указывая его в виде  параметра  {addr}.
Если  же  параметр  _addr_ не указан, то  ввод  и  ассемблирование
начинается с текущего адреса, выделенного маркерной полосой.
    Перемещение командного дампа  по адресному пространству программного
сегмента  памяти,  при  его  просмотре,  осуществляется  клавишами
управления курсором: клавишами-стрелками, а также клавишами  _Page
Up_ и _Page Down_.  Выход из режима ассемблирования осуществляется
нажатием клавиш _Ctrl/Enter_.
    Из-за ограничения длины строки в поле дизассемблирования,  для
представления  указателей установлена специальная  мнемоника.  Так
указатель _WORD PTR_ отображается как _W/_, а указатель _BYTE PTR_
-  как _B/_. Если для однооперандной команды, которая указывает на
ячейку  памяти не задан указатель, то по умолчанию подразумевается
./%` f(o над словами.
    Пример: A cs:0100


    BE{ep} {ON!OFF} - (Beep).
    Директива, с помощью которой включается (с параметром ON)  или
выключается (с параметром OFF) звуковой сигнал сопровождения. Если
директива  задается без параметра, на экране, непосредственно  под
командной строкой отображается текущее состояние системы звукового
сопровождения (т.е. ON или OFF).
    Примеры:  BE ON
                       BEEP OFF

    BL filename - (Breakpoint Load).
    Директива загрузки указанного файла данных о распределении контрольных
точек  и их параметров, который формируется предварительно в  виде
специальной таблицы и сохраняется во внешней памяти (см. директиву
_BW_). После загрузки автоматически происходит и активизация  этих
контрольных точек (см. раздел - _ Работа с контрольными точками_).
    Примеры:  BL e:\matush\lab.brk
                        BL PROG. BRK

    BR {filename} - (Brouse).
    Директива просмотра в кодах ASCII файла, указанного в _filename_.Файл
отображается  во  вновь  сформированном  окне  на  поле  дампа  2.
Перемещение  отображения файла в окне осуществляется одновременным
нажатием  клавиши _Ctrl_, а также клавиш _Page Down_ (при смещении
вперед) или _Page Up_ ( при смещении назад).
    Если  перед  этим, директивой _BR filename_ был  уже  загружен
некоторый  файл,  то  в дальнейшем директива  _BR_,  заданная  без
параметра, будет вызывать на экран этот же файл. Отмена  просмотра
происходит после нажатия клавиши _Enter_.
    Примеры:  BR Lab.sym
                       BR e:\matush\Prog.txt

     BW filename - (Breakpoint Write).
    Директива,  позволяющая сохранить в виде файла  под  указанным
именем    сформированную   пользователем    таблицу    расстановки
контрольных  точек вместе с их параметрами (см. раздел  _Работа  с
*.-b`.+l-k,( точками_).
    Примеры:  BW Lab.brk
                        BW e:\matush\prog.brk

    C addr1, addr2,length - ( Compare).
    Директива, позволяющая сравнить коды двух областей оперативной
памяти, начинающихся, соответственно, с адресов _addr1_ и _addr2_,
и  имеющих  длину в байтах  _length_. Если разница обнаружена,  то
под  командной  строкой  отображается  информация  о  несовпадении
кодов.  При  этом,  начиная с различающихся  байтов,  коды  первой
области отображаются в поле дампа1, а коды второй области - в поле
дампа2.
    Если  массивы  кодов  одинаковы,  то  под   командной  строкой
отображается информация о равенстве всех байтов.
    Примеры:  C 02FA, 1345, 41
                        C ds:0123, es:3456, 35

    CO source_addr, destination_addr, length - (Copy).
    Директива копирует массив кодов длиной "length" байт, расположенный в
памяти,  начиная  с  адреса  "source_addr",  в  область  памяти  с
начальным  адресом  "destination_addr". По  умолчанию  копирование
происходит в сегменте данных DS:.
    Примеры:  CO 5678, 1234, 68
                        CO ds:1234, es:0000, 57

    D addr - (Disassembler).
    Директива  задает начальный адрес кода, с которого  начинается
дизассемблирование.   Этот   адрес   в   поле   дизассемблирования
выделяется  маркерной полосой. При задании директивы с  параметром
"*" (т.е. вида "D*") начало дизассемблирования устанавливается  по
адресу 0100.
    Примеры:  D 0350

    DI{r} {filename} - (Directory).
    Директива позволяет вызвать на экран в поле дизассемблирования и
просмотреть, указанный в "filename" каталог файлов, хранящийся  во
внешней  памяти  компьютера.  При  этом,  маршрут,  указываемый  в
"filename", оформляется по правилам, общепринятым в DOS.
    Просмотр содержимого вызванного каталога, при списке, превышающем
`  ',%`k  поля, осуществляется его перемещением с помощью  клавиш-
стрелок  или клавиш "Page Up" и " Page Down). При этом, на границе
с полем командной строки, справа, высвечивается общее число файлов
вызванного каталога.
    Примеры: DI e:\matush
                       DI d:\

    DM {88!V20!286} - (Disassembler Mode).
    Директива определяет тип используемого процессора для генерации
дополнительных  команд. Задаваемая без параметра она  представляет
собой  запрос к отладчику о текущем типе процессора. В этом случае
непосредственно под командной строкой появляется информация о том,
для какого типа процессора задействован Ассемблер и Дизассемблер.
    Пример: DM 286

    F addr, repeat_count, string - (Fill).
    Директива,  позволяющая заполнять память  последовательностями
символов,  указанных  в _string_. Заполнение начинается  с  ячейки
памяти  по  адресу _addr_. Заданная последовательность  непрерывно
повторяется    число   раз,   указанное   в    _repeat_count_    в
шестнадцатеричной или десятичной (если указан префикс _%_)  форме.
Последовательность _string_ может представлять собой  совокупность
шестнадцатеричных  цифр и строк символов ASCII  (последние  должны
быть заключены в кавычки).
    По умолчание задается сегмент данных DS: .
    Примеры:  F 0200, %25, 3FA9_TABLO_
                        F es:0000,10,123_segment_456

    G {start_addr}{,{/D} break_addr} - (GO).
    Директива , позволяющая запустить отлаживаемую программу на исполнение,
начиная  с  адреса, указанного в _start_addr_  и  с  остановом  по
адресу, указанному в _break_addr_. Другие возможные места останова
выполнения   программы   определяются   контрольными   точками   с
остановом,  задаваемыми в опции _Break Menu_ (переход  по  нажатию
функциональной клавиши F5).
    Исполнение программы может быть прервано оновременным нажатием клавиш
_Ctrl/Esc_. Ключ _/D_ рарешает прерывать программу по DOS-функциям
(INT - 21).
    В  случае,  если  параметры директивы не  указаны,  исполнение
/`.#`  ,,k  начнется  с  текущего  адреса,  отмеченного  маркерной
полосой в поле дизассемблирования.
    Отметим,  что  при запуске программы директивой _G_,  счетчики
числа  проходов  контрольных  точек  _Occur_,  содержимое  которых
отображается  на карте расстановке контрольных точек, сбрасываются
в  нулевое состояние и , таким образом, подсчет числа проходов при
нескольких  последовательных запусках программы будет  происходить
каждый раз с нулевого значения.
    Примеры:  G
                        G 0100
                        G 0100, 04FF
                        G 0100, /D 015E

    GC {/T} {/A} {start_addr}{,{/D} break_addr} - (Go Continue).
    Директива _GC_ выполняет ту же функцию запуска отлаживаемой программы
на  исполнение,  что  и  директива _G_. Однако  при  использовании
директивы  _GC_, режим трассировки и анализа может  быть  задан  в
самом  формате директивы, введя соответствующие ключи  _/T_  или/и
_/A_.  В  этом  случае  трассировка и анализ  будут  производиться
независимо от того, указаны ли в поле _Action_ таблицы расстановки
контрольных точек атрибуты _T ON_ или _A ON_, а так же  независимо
от  того,  вводилась ли директива разрешения трассировки _TR  ON_.
При  этом, трассировка будет фиксироваться начиная непосредственно
с команды, адрес которой указан в директиве _GC_ как _start_addr_.
    Если же ключи _/T_ или/ и _/A_ в директиву _GC_ не введены, она
исполняется  аналогично директиве _G_ с тем только  отличием,  что
при  запуске  программы по директиве _GC_ счетчики числа  проходов
контрольных точек _Occur_ не сбрасываются автоматически в  нулевое
состояние при последующем запуске а, следовательно, при нескольких
последовательных  запусках  по этой директиве,  число  фактических
проходов контрольных точек будет накапливаться (суммироваться).
    Примеры:  GC
                        GC 03FF
                        GC /T /A 0100, /D 02A7

     IN {/W} port_addr - (Input).
    Директива,  позволяющая  прочесть  и  отобразить   на   экране
дисплея,  непосредственно  под полем  командной  строки,  значение
байта (если с ключем "/W", то шестнадцитибитового слова ) из порта
"".$ /вывода, номер которого указывается в "port_addr".
    Примеры:  IN 02
                        IN /W 14

    INT number - (Interrupt).
    Данная дирктива инициирует выполнение прерывания с номерами от 00 до
FF,   указываемыми  в  "number".  При  этом  возможные   изменения
состояния регистров процессора, будут отображаться на экране.
    Пример:  INT 10

    L {/P} {/addr} filename {parameter} - (Load).
    Директива,   инициирующая  загрузку  .EXE   или   .COM   файла
программы,   имя   которого   указано   в   "filename".   Загрузка
программного файла осуществляется по умолчанию, начиная с  адреса:
CS:  0100.  Если  адрес  указан  без  сегмента,  то  по  умолчанию
используется  текущее  значение сегмента  кода.  Если  не  указано
расширение  файла , то по умолчанию используется расширение  .EXE.
Если  имя  файла не имеет расширения, тот имя должно заканчиваться
точкой,  чтобы  избежать генерации расширения по умолчанию.  Когда
после  имени  файла  вводятся параметры, эти данные  помещаются  в
префиксный сегмент программы (PSP).
    При  загрузке  файла данных может быть задан  начальный  адрес
("addr"), по которому должен быть загружен этот файл.
    Ключ "/P2 используется, если загружаемая программа хранится  в
упакованном виде (EXPACK).
    Примеры:  L Prog1.com
                        L /DS:0200 Prog2.exe

    LS {/A} {filename} - (Load Symbols)
    Директива загрузки и инициирования символьных данных. Если имя файла в
директиве не указано, то введется файл с расширением .MAP и именем
последней загруженной программы.
    Ключ _A_ используется при введении дополнительных символов к уже
загруженным.  Если дополнительные символы ввести без этого  ключа,
то  исчезают  все  ранее  введенные символы.  Файл  дополнительных
символов  может быть организован под любым именем.  В  нем  должны
быть даны соответствия адресов и вводимых символов. Например:
                                         0000:0387    Lab1
                                         0123:0876     M1
                                              и т.п.
    Примеры:   LS Prog1.sym
                         LS /A Symbol.ask

    M1 addr! seg_reg:addr - (Memory Window)
    Директива, позволяющая вызывать на экран дисплея в поле 1 дамп
кодов,  размером  80 байт, хранящийся в памяти начиная  с  адреса,
указанного  в  _addr_ в текущем сегменте (или  в  _seg_addr_,  при
выборе  дампа  из  другого  сегмента).  Возможно  изменение   этой
директивой только типа сегмента, без изменения адресного  смещения
в  нем.  Начальный  адрес дампа может быть также  задан  косвенно,
используя в директиве вместо указания кода адресного смещения, имя
регистра, в котором оно содержится.
    Последующее перемещение дампа по адресному пространству  может
осуществлятся клавишами-стрелками, а также клавишами _Page  Up_  и
__Page  Down_, предварительно переведя курсор в это поле с помощью
функциональных клавиш F7...F10.
    Примеры:  M1 0100
                        M1 DS:1234
                        M1 FS:SI+1234-DI
                        M1 [SI]
                        M1 ES

    M2 {/A} addr!seg_reg:addr - (Memory Window 2)
    Директива,  аналогичная директиве M1, но  вызывающая  дамп  из
памяти во второе, нижнее поле 2. Второе поле отличается от первого
еще   и   тем,   что  в  крайкей  правой  его  части  одновременно
отображается представление кодов этого дампа в символах ASCII. При
этом,  при  желании ограничить отображение символов  ASCII  только
первой  половины  кодовой таблицы, а также  исключить  отображение
кодов  управляющих сигналов (т.е. преобразовывать коды в диапазоне
от 02H до 7FH) директива должна использоваться с ключом _/A_.
    Примеры:  M2 ES:DI+4321
                         M2 /A 1234

    MO{de} M{ono}!C{olour}!A{ltern} ON/OFF - (Mode)
    Директива _MO{de}_ задает режимы работы экрана экрана дисплея:
    M{ono}- при использовании монохроматического адаптера;
    C{olour) - при использовании цветного адаптера;
    A{ltern} - при использовании режима переключения экрана:
            A ON - включение режима переключения экрана;
            A OFF -выключение режима переключения экрана.
    При  задании  директивы _MO A ON_, т.е. при включенном  режиме
переключения   экрана,  экран  дисплея  с  помощью  функциональной
клавиши  F6 может переключаться от отображения текущего  состояния
полей отладчика AFDPror к отображению состояния буфера экрана DOS.
Таким  образом,  эта  директива дает  возможность  отображения  на
экране данных, извлеченных из _теневого экрана_. _Теневой экран_ -
это  область памяти, где фиксируется то состояние экрана,  которое
было  бы  при  обращении  к  нему  отлаживаемой  программы.  Такое
переключение  очень  полезно,  например,  для  текущего  просмотра
результатов   выполнения  отлаживаемой  программы  из   отладчика,
особенно графиков, диаграмм, таблиц и т.п.
    Когда AFDPror запущен в резидентном режиме, альтернативный режим
A{ltern} включается автоматически.

    O{/W} port_addr,value - (Output)
    Директива,  позволяющая выводить данные в порты. Данные  могут
указываться  непосредственно  и  косвенно,  через  указание   имен
регистров  их  содержащих. Данные могут быть представлены  в  виде
выражений.  Если  данные представляют собой  16  разрядные  слова,
директива  дается  с  ключом  _/W_.  При  выводе  байта  ключ   не
используется.
    Номер порта, в пределах ) 0...3FFH, указывается _port_addr_, а сами
данные   в   _value_.   Указание  номера  (адреса)   порта   может
осуществляться так же в виде выражений и косвенно через регистры.
    Примеры:  O  67,23
                        O  /W 77,AX+DX+1234
                        O  DI+3,AX+SI

    P addr,string - (Path)
    Директива,  позволяющая  занести в оперативную  память  строку
данных,  приведенную в _string_, с начальным адресом, указанным  в
_addr_.    Строка    может   состоять    из    любой    комбинации
шестнадцатеричных кодов, а также строк символов ASCII, заключенных
в  кавычки.  Шестнадцатеричные коды в строку  могут  быть  введены
косвенно, указывая имена регистров, где они содержатся.
    Начальный адрес может быть приведен с указанием сегмента и смещения в
-%,.  Если  имя  сегмента  опущено, то  по  умолчанию  принимается
сегмент данных DS.
    Примеры:  P DS:11FA,12 3EC _text_ SI25
                        P 0112,AX1234

    PD addr,length{,filename} - (Print Disassembler)
    Директива,  позволяющая  выводить на принтер  или  во  внешнюю
память   ввиде   файла,  под  именем,  указываемом  в   _filename_
дизассемблированное  содержимое  оперативной  памяти,  начиная   с
адреса,  задаваемого  в  _addr_ и длиной  в  байтах,  указанной  в
_length_.  При обращении к другим каталогам в спецификации  файла,
можно указывать маршрут. По умолчанию задается кодовый сегмент CS.
    Результат фиксируется в виде текстового файла с адресами ячеек памяти,
кодами,  содержащимися  в  этих  ячейках,  а  также  ассемблерными
выражениями, соответствующими этим кодам.
    Примеры:  PD 0100,46
                        PD 0300,57,Prog1.txt

    PH {/A} addr,length{,filename} - Print Hex
    Директива,  позволяющая  выводить на принтер  или  во  внешнюю
память,   в   виде  файла  под  именем,  указанным  в  "filename",
содержимое оперативной памяти, начиная с адреса "addr" и длиной  в
байтах,  указанным  в  "length".  Результат  фиксируется  в   виде
шестнадцатеричных кодов, а также соответствующих  символах  ASCII.
При  желании  ограничить отображение символов ASCII только  первой
половины  кодовой  таблицы,  а также  исключить  коды  управляющих
сигналов  (т.е.  преобразовывать в символы  ASCII  коды  только  в
диапазоне  от  02H  и до 7FFH), директива должна использоваться  с
ключом "/A". Для обращения к другим каталогам в спецификации файла
можно указывать маршрут.
    По умолчанию задается сегмент данных DS.
    Примеры:  PH 0FFF,40
                        PH /A,CS:0100,35,D:\matush\memory.txt

    PT {/S} {start,length{,filename}} - Print Trace
    Данная  директива позволяет выводить на принтер или во внешнюю
память,  в  виде  файла  под  именем,  указанным  в  "  filename",
содержимое  трассировочного  буфера.  "start"  представляет  собой
номер   начальной   выводимой  записи  трассировки,   а   "length"
./`%$%+o%b число выводимых записей.
    С   ключом   "/S"   выводятся  только   выполненные   команды,
зафиксированные  в  трассировочной  буферной  памяти  (в  кодах  и
ассемблерных  выражениях),  а также  их  адреса,  без  отображения
содержимого регистров процессора и вершины стека.
    При  обращении к другим каталогам в спецификации  файла  можно
указыват маршрут.
    Примеры:  PT 01,%47
                        PT %10, 8, e:\matush\buffer.txt
                        PT /S 0, 21, buffer.txt


    QUIT {R{esident}}
    Директива конца работы отладчика и возвращение в DOS. Параметр R делает
отладчик  AFDPror резидентным. В этом случае он может быть  вызван
снова  по  входу немаскируемого прерывания (NMI) или одновременным
нажатием клавиш "Ctrl/Esc". Сама директива "QUIT" должна вводиться
полностью  для  того, чтобы избежать непреднамеренного  завершения
работы AFDPror. Параметр может быть сокращен до одного символа.
    В  резидентном  режиме  программы не могут  быть  загружены  с
помощью  AFDPror.  Если необходимо загрузить программу  с  помощью
AFDPror, пользователь может запустить AFDPror еще раз, в то  время
как  резидентный  вариант AFDPror попрежнему  будет  находиться  в
памяти.
    Если AFDPror используется в резидентном режиме, то около 64 Кбайт
памяти,   которые   он   занимает,  становятся   недоступным   для
операционной системы.

    {R} reg = value - (Register)
    Директива,  позволяющая заносить в любой  программно-доступный
регистр  "reg"  четырехзначный шестнадцатеричный  код  "value".  К
указанным  регистрам  относятся  также  вспомогательные   регистры
отладчика  "HS" и "FS". При занесении 16 битового слова в  регистр
флагов,  его  имя  определяется как  "FL".  Можно  также  заносить
двоичные  значения в отдельные разряды регистра флагов,  используя
их имена: "OF", "DF", "CF" и т.д. При задании директивы, справа от
знака  равенства  могут быть арифметические выражения,  в  которых
использованы знаки: "+", "-", "*", "/". Все вычисления выполняются
строго   слево  направо  над  16  разрядными  беззнаковыми  целыми
g(a+ ,(. Переполнение игнорируется.
    Примеры:  R AX=1FA5
                            CX=0175
                            FL= 7202
                            DF=0

    RD addr,drive,head,track,sector,s_count - (Read Disk)
    Директива, позволяющая скопировать содержимое секторов  памяти
дисководов A...D в оперативную память отладчика начиная  с  адреса
"addr". При этом: "drive" - обозначение дисковода;
             "head" - номер головки;
               "track" - номер цилиндра;
               "selector" - номер сектора начала считывания;
               "s_count" - число секторов, подлежащих считыванию.
    Результат может быть просмотрен с помощью дампов в полях 1 и 2.
    По умолчанию задается сегмент данных DS.
    Примеры:  RD 0100,B, 2, 5, 3, 5

    S {{addr}, string} - (Search)
    Директива поиска. Она позволяет отыскать в оперативной памяти цепочку
(строку) символов "string", которая может представлять собой любую
комбинацию   шестнадцатиричных  цифр  и  строк   символов   ASCII,
выделенных  кавычками.  Поиск  осуществляется,  начиная  с  адреса
"addr",  который может быть задан в виде сегмента и смещения.  Как
значение сегмента, так и значение смещения в нем могут быть заданы
любыми  арифметическими  выражениями. Если  значение  сегмента  не
введено,  то  по умолчанию используется текущее значение  кодового
сегмента CS. Просматривается все адресное пространство, начиная  с
указанного в директиве адреса.
    Когда данные найдены, они отображаются в поле дампа 2, начиная с
первого байта искомой цепочки. Адрес первого байта искомой цепочки
определяется  базовым адресом сегмента, заносимым в регистр  HS  и
смещением в этом сегменте, отображаемом в поле дампа 2.
    Если  требуется продолжить поиск заданной цепочки  символов  в
остальной области памяти, снова задается директива S, но  уже  без
параметра.
    По умолчанию поиск осуществляется в сегменте данных DS.
    Примеры:  S ds:0100,1234567890"test"
                        S ip-dx+bx,"Word-Windows"
                        S

    SI {{addr},instruction} - (Search Instruction)
    Директива поиска в оперативной памяти заданной ассемблерной команды
"Instruction",   начиная  с  адреса  "addr".   Найденная   команда
выделяется  маркерной  полосой  в  поле  дизассемблирования  (поле
отлаживаемой  программы).  Если  адрес  не  указан,  поиск   будет
осуществляться,  начиная с текущей команды,  выделенной  маркерной
полосой.  Если  не  указан тип команды, будет производиться  поиск
команды, заданной перед этим.
    По умолчанию поиск осуществляется в кодовом сегменте CS.
    Примеры:  SI 0100,jmp 1234
                        SI PUSH ES
                        SI

    SY {ON!OFF} {/C ON!OFF} {filename} - (Symbols display)
    Директива,  позволяющая убирать с экрана дисплея (с параметром
"OFF",   или   снова  выводить  на  экран  (с  параметром   "ON"),
загруженные  до этого символы файла "filename". Символьные  данные
отображаются  непосредственно  в  поле  дизассемблирования   (поле
отлаживаемых программ) по соответствующим адресам.
    Директива, введенная без параметров, выводит на экран на месте
поля  дампа  2  полную  таблицу заданных символьных  данных.  Если
массив  символьных данных не укладывается в поле  полностью  ,  их
можно просматривать в этом поле по частям, используя одновременное
нажатие  клавиш  "Ctrl/Page Up" или "Ctrl/Page  Down".  Ключ  "/C"
позволяет   включать  (ON)  или  выключать  (OFF)   режим   "case-
sensitivity",  при  котором  различаются  заглавные   и   строчные
символы.
    Примеры:  SY ON Symbol.txt
                        SY ON
                        SY /C ON
                        SY

    T - (Trace Display)
    Директива,  позволяющая просмотреть на экране дисплея  в  поле
дизассемблирования   ту  часть  отлаживаемой  программы,   которая
выполнена  при  задании и инициировании трассировки  и,  результат
выполнения  которой  зафиксирован в буферной  памяти  трассировки.
Qдвиг отображения в окне осуществляется при помощи клавиш-стрелок,
а  также  клавиш  "Page  Up"  и "Page Down".  Возврат  в  исходное
состояние происходит при нажатии клавиши "Enter" или "F1".

    TB {/S} - (Trace Buffer Display)
    Директива,выводящая  на  экран  дисплея  содержимое   буферной
памяти  трассировки.  С  ключом "/S" директива  выводит  на  экран
только  выполненные  во  время трассировки  команды  вместе  с  их
адресами.  По  сравнению  с  директивой  "T"  директива  "TB   /S"
отображает  одновременно более чем в два  раза  число  выполненных
команд,  на  полном  экране  и  с указанием  значения  сегмента  в
представлении    адреса   каждой   команды.   Сдвиг    отображения
осуществляется  также при помощи клавиш-стрелок,  а  также  клавиш
"Page  Up"  и "Page Down". Возврат в исходное состояние происходит
также по нажатию клавиш "Enter" или "F1".

    TR {ON!OFF} {CLR} - (Trace Control)
    Директива контроля и управления режима записи трассировки отлаживаемой
программы.  С  параметром  _ON_ директива  включает  режим  записи
трассировки,   а   с   параметром   _OFF_   выключает   его.   Для
предварительной очистки буфера трассировки директива  используется
с  параметром _CLR_. Директива, введенная без параметров,  выводит
на  экран,  непосредственно под командной  строкой,  информацию  о
включенном  (_Trace  is  ON_)  или выключенном  (_Trace  is  OFF_)
состоянии режима трассировки программы.
    Примеры:  TR OFF
                        TR ON CLR

    W {addr,length,filename} - (Write)
    Директива,  позволяющая сохранять во внешней памяти компьютера
содержимое оперативной памяти, начиная с адреса _addr_, где _addr_
-  адрес  первого байта сохраняемого массива. При этом _length_  -
длина  сохраняемого массива в байтах, а _filename_ -  полное  имя,
под которым будет храниться запоминаемый массив. Если параметры не
указаны,  директива  использует  параметры  файла,  которые   были
использованы  при последней загрузке с помощью директивы  _L_.  По
умолчанию задается сегмент данных DS.
    Примеры: W CS: 0100,45,Prog1.exe
                       W

    WD addr,drive,head,track,sector,s_count - (Write Disk)
    Директива,   позволяющая   сохранить  содержимое   оперативной
памяти,  начиная  с  адреса _addr_,  на  внешней  дисковой  памяти
компьютера   с   указанием  дисковода  A...D   (_drive_),   номера
записывающей   головки  (_head_),   цилиндра  (_track_),   сектора
(_sector_),  а  также числа записываемых секторов (_s_count_).  По
умолчанию задается сегмент данных DS.
    Пример:  CS:0100,D,1,2,5,3

    XL filename - (Macro Load)
    Директива,  загружающая в оперативную память  файл  макроса  с
именем  _filename_, созданного по директиве _XT_ и записанного  во
внешнюю память по директиве _XW_.
    Пример:  XL Key.mac

    XT - (Macro Teach)
    Директива,  определяющая  начало  (инициирование)  запоминания
последовательности  нажатия  клавиш  в  ее  буферной  памяти.  Эта
последовательность  запоминается в виде последовательности  кодов,
вырабатываемых  при  нажатии  клавиш  (макроса).   Конец   макроса
определится при одновременном нажатии  клавиш _Ctrl/Break_ или при
полном  заполнении  буферной  памяти клавиатуры,  емкость  которой
равна 128 байтам.

    XW filename - (Macro Write)
    Директива записи содержимого буферной памяти клавиатуры, выделенного
как макрос, во внешнюю память, под именем _filename_.
    Пример:  XW Key.mac

    XX {filename} - (Macro Execute)
    Директива,  инициирующая  выполнение  макроса,  т.е.  эмуляцию
запомненной  последовательности нажатий  клавиш  клавиатуры.  Если
файл  макроса уже загружен директивой _XL_, директива  _XX_  может
быть задана без указания _filename_. Если файл еще не загружен, то
директива   должна   сопровождаться   указанием   имени    макроса
_filename_.  При этом директива _XX_ сначала загружает  макрос,  а
затем выполняет его.

            Раздел III. Работа с контрольными точками.

    Правильная расстановка контрольных точек и целенаправленное задание их
атрибутов имеет очень большое значение при отдадке программ.
    Контрольная точка - это адрес некоторой команды выполняемой программы,
который определяется пользователем при подготовке этой программы к
отладке.    Достижение     контрольной    точки,    т.е.    адреса
соответствующей   команды   при   выполнении   программы,    может
сопровождаться   некоторыми,  заранее   определенными   действиями
программы   отладчика.  Задание  контрольных  точек  осуществляеся
пользователем  с  помощью таблицы расстановки  контрольных  точек,
выводимой  на  зкран  (а также убираемой с экрана)  путем  нажатия
функциональной клавиши F5 (_BRK Menu_).  Данная таблица  позволяет
задать   8   контрольных  точек  по  любым  адресам   отлаживаемой
программы,   7   типов  действий,  которые  могут  произойти   при
достижении  контрольной  точки,  а  также  число  проходов  данной
контрольной   точки   и   дополнительные  условия,   при   которых
реализуются   заданные  действия.  Обработка   контрольных   точек
происходит в порядке возрастания их адресов.
    Таблица задания контрольных точек (см. Рис 2) включает в себя 7
колонок   (полей)  атрибутов,  из  которых  одна  ("№")   содержит
фиксированные  номера  восьми контрольных  точек,  четыре  ("Break
ADR", "Condition", "Count" и "Actoin") определяются пользователем,
а   содержимое   еще   двух   ("BR"  и  "Occur")   устанавливаются
автоматически самим отладчиком.
    При первоначальном входе в "BRK Menu" курсор указывает на символ
"-"  в  поле  адреса  первой  контрольной  точки,  который  должен
исчезнуть при задании адреса. Каждый раз, при перемещении  курсора
на  следующее поле (клавишами "Enter" или "Tab") или на предыдущее
поле  (клавишами "Shift/Tab"), курсор будет становиться  в  начало
нового  поля.  Внутри полей перемещение курсора  осуществляется  с
помощью клавиш стрелок.
    Для стирания всего поля, на котором находится курсор, необходимо
нажать  клавишу  "Esc".  Каждое поле  (условия,  действия  и  др.)
обрабатываются  отдельно. Для стирания символа в  текущей  позиции
курсора  используется  клавиша  "Del".  Для  удаления  только  что
введенного  символа,  слева от курсора, нажимается  клавиша  "Back
Space".  Клавиша  "  Ins"  используется для  переключения  режимов
вставки  и  замены.  В  режиме вставки  курсор  имеет  вид  яркого
/`o,.c#.+l-(*  размером в половину знакоместа. При вводе  символов
в режиме вставки,все символы справа от курсора сдвигаются вправо.
    Введенные данные проверяются и интерпретируются в момент выхода из
заполненного  поля.  При ошибке курсор устанавливается  на  первый
неверный  символ  в данном поле и выводится сообщение  об  ошибке.
Покинуть поле, в котором выявлена ошибка можно только в случае  ее
исправления или очистки данного поля с помощью клавиши "Esc".
    Кроме упомянутых выше, при задании контрольных точек используются
следующие  клавиши:  "Ctrl/F6"  - стирание  содержимого  до  конца
текущего поля; "Ctrl/Home" - перевод курсора в поле адреса  первой
контрольной точки BR1.
    Ниже  рассмотрим  подробнее назначение полей  таблицы  задания
контрольных   точек   отлаживаемой  программы,   и   атрибутов   (
параметров) вводимых контрольных точек.
    Break_ADR  - поле,в котором задается адрес контрольной  точки.
Если в этом поле будет отображен символ _-_, то данная контрольная
точка  не  активна.  Адрес  контрольной точки  может  быть  указан
значением   сегмента   и   смещения.   Например:   _CS:0100_   или
_2567:0100_.  Если указывается только смещение,  то  по  умолчанию
задается  кодовый  сегмент CS (указывается  его  начальный  адрес,
содержащийся в сегментном регистре CS). Обратите внимание на то  ,
что   результирующий  физический  адрес  должен  быть  обязательно
адресом  начала  команды  (ее  первого  байта).  Иначе,  установка
контрольных точек может привести к непредсказуемым результатам при
запуске отлаживаемой программы.
    Предусмотрена возможность переносить любую контрольную точку, вместе с ее
параметрами,   с прежнего адреса на текущий, отмеченный  маркерной
полосой  в  поле отлаживаемой программы (поле дизассемблирования).
Для этого требуется одновременное нажатие клавиши _Alt_ и цифровой
клавиши, соответствующей номеру данной контрольной точки.
    Condition  - поле условий. Для каждой контрольной точки  может
быть введено до 8 условий. Условия должны разделятся пробелом  или
запятой. Для отметки прохода данной контрольной точки и увеличения
на единицу счетчика проходов _Occur_, все указанные условия должны
быть  истинны. Таким образом, над всеми условиями в  поле  условий
выполняется операция коньюнкции (AND).
    Условия,  задаваемые для данной контрольной точки  могут  быть
двух типов:
    1.  Фактическое прохождение некоторой другой точки такое число
`  ', которое определено в ее поле _Count_. Задается это условие в
виде  _BRN_,  где N номер этой контрольной точки.  Таким  образом,
условие  _BRN_ становится истинным только тогда, когда  содержимое
счетчика  проходов  _Occur_  контрольной  точки  N  станет  равным
значению, заданному в ее поле _Count_.
    2.  Равенство  или отношение двух операндов. Эти два  операнда
могут   быть  связаны  знаком  отношения:  _>_,  _=_,_<_.  Условие
становится  истинным,  когда  равенство  или  отношение   является
истинным. В качестве первого операнда могут служить:
    -   имя  регистра  (при  этом  используется  содержимое  этого
регистра);
    -  адрес ячейки памяти ( при этом используется содержимое этой
ячейки         памяти).
    Адрес ячейки памяти в квадратных скобках задается либо прямо, либо
косвенно,  через  указание имени регистра.  При  прямой  адресации
используется  обычная  форма записи адреса  -  _сегмент:смещение_.
Если спецификация сегмента пропущена, то по умолчанию используется
сегмент  данных DS. При косвенной адресации указывается какой-либо
из 16 разрядных регистров, перед которым может быть указан регистр
сегмента.  Если  регистр  сегмента  не  указан,  то  по  умолчанию
используется сегмент данных DS. Примеры записей первого  операнда:
DX; [CX]; [0100]; [SS:0200]; [ES:AX].
    В  качестве  второго операнда, кроме имени регистра  и  адреса
ячейки  памяти,  может быть непосредственно  указана  константа  -
четырехзначное  шестнадцатеричное  число.  Внутри  числа,   вместо
шестнадцатеричной  цифры  может  быть  поставлен  символ  _X_  для
указания  того , что значение этой цифры не играет роли.  Значение
константы  может быть задано и как десятичное число,   если  перед
ним указан символ _%_. Примеры констант: 1205; AXX9; %5678.
    Если  второй  операнд  задан регистром или  ячейкой  памяти  (
аналогично  первому  операнду), он  может  быть  задан  вместе  со
смещением  или  с  маской.  Маска  и  смещение  определяются   как
четырехзначные  шестнадцатеричные числа, где задаются  все  четыре
цифры.  В  случае, если дано смещение (со знаком _+_ или _-_),  то
оно    прибавляется   к   значению   операнда   перед    проверкой
равенства/отношения.
    Когда  задана маска, над каждым из двух операндов  выполняется
поразрядная операция коньюнкции (AND) с указанной маской перед тем
как  выполняется  проверка на равенство/отношение.  Это  позволяет
(a/.+l'."  bl  для  сравнения  только  отдельные  разряды.   Маска
добавляется через символ _&_.
    Примеры вторых операндов, заданных регистром или ячейкой памяти: AX;
AX+1234; [ES:CX]; [SS:0023]; [ES:AX]&10F8.
    Примеры записей в поле "Condition":
      BR5, AX > = 0256, CF =3, [DS:SI] = /W [ES:32B4]
    (Обозначения:   "/W"  и  "/B"  эквивалентны,   соответственно,
обозначениям "Word PTR" и "Byte PTR" и введены в AFDPro для  более
компактного представления строк условий).
    Count  -  поле  счетчика. В этом поле задается число  проходов
данной  контрольной,  при  котором  допускается   (при  выполнении
условий,  заданных в поле "Condition"),  инициирование контрольной
точки  и  выполнение  действий, заданных в  поле  "Action".  Число
проходов  задается  непосредственно  в  десятичном  виде   и   его
максимальное значение может достигать 65535. Если в поле  счетчика
занесен 0, то данная контрольная точка не активна.
    Action  - поле типов действий, осуществляемых после реализации
заданного  в поле "Count" числа проходов данной контрольной  точки
при  выполнении  условий,  заданных в  поле  "Condition".  В  поле
"Action" может быть одновременно задано несколько различных  типов
действий  (операций), если длина поля достаточна  для  их  записи.
Каждая операция может быть задана своим полным названием или любым
его  сокращением  (  в  названии  могут  быть  сокращены  символы,
заключенные  в  фигурные скобки).При вводе названий  операций  оно
должно  быть  отделено  от  параметра или  от  названия  следующей
операции пробелом или запятой.
    Определены следующие операции:
    -  C{ount}  - , операция, делающая контрольную точку активной,
но  в  тоже  время, не выполняющая никаких других действий,  кроме
подсчета  количества  прохождений данной  контрольной  точки.  Эта
операция  обычно используется для реализации условия инициирования
других контрольных точек (условие "BRn" в поле "Condition")
    -  Break - , операция, прерывающая выполнение программы вплоть
до  нового  ее запуска (с отображением следа трассы, если  включен
режим трассировки).
    -   R{estart}nm... - , операция перезапуска контрольных точек.
Она    сбрасывает   в   исходное   нулевое   состояние    счетчики
зафиксированных  чисел  проходов "Occur"  тех  контрольных  точек,
номера которых перечисляются в виде - nm... .
    - T{rase} ON!OFF{NI} - ,операция, включающая (с параметром ON)
или   выключающая   (с  параметром  OFF)  трассировку   выполнения
программы, с фиксацией следа в трассировочном буфере. При  задании
операции  "T ON" и при инициировании запуска программы  директивой
"G"  или  "GC"  без  ключа  "/T",  трассировка  (при  условии   ее
разрешения  директивой "TR ON") включается, начиная  с  указанного
(или  текущего)  адреса  и продолжается по достижении  контрольной
точки  (при  условии выполнения заданного числа  ее  проходов),  у
которой задана операция "T OFF), или до первого останова.
    При запуске программы директивой "GC" с ключом "/T" трассировка
будет  автоматически включаться, независимо от  задания  директивы
"TR  ON!OFF"  и  независимо от задания  операции  "T  ON"  в  поле
"Action".
    По  достижении контрольной точки, где задана операция "T  OFF"
,программа  выполняется и дальше но, начиная с данной  контрольной
точки и до следующей контрольной точки с операцией "T ON", либо до
останова программы, след трассировки не фиксируется.
    При  задании  операции "T OFF NI",  след трассировки  основной
программы  в  буферной памяти фиксируется, однако след трассировки
подпрограмм обработки прерываний, вызываемых командами прерываний,
в  трассировочный  буфер не заносятся. Это бывает  очень  полезно,
когда основная программа выполняет много обращений к DOS или BIOS.
    -  S{nap}  - операция, которая реализуется только в  диапазоне
действия  "T OFF", т.е. при выключенной трассировке. Она позволяет
в  данном  диапазоне зафиксировать в трассировочном  буфере   след
выполнения  только  тех  команд,  по  адресам  которых  поставлены
контрольные точки с операцией "S".
    -  A{nalyse}  ON!OFF - операция включения/выключения  проверки
условия.  Если  задано "A ON", то проверка условия  осуществляется
после каждой команды.
    - J{ump} addr - операция, которая позволяет перескакивать, при
фиксировании  следа  трассировки, сразу на  контрольную  точку  по
адресу,  указанному в "addr" и, следовательно, не оставлять  следа
трассировки программы в промежутке между ними.
    Как  уже упоминалось выше, в таблице задания контрольных точек
имеется  еще две колонки, в полях которых отображается  информация
самим   отладчиком  в  процессе  отладки  программы  с  введенными
контрольными точками.
    В  первой  из них, колонке полей "BR", появляется символ  "C>"
/.a+%  того,  как данная контрольная точка полностью задана,  т.е.
задан  ее  адрес, условия, требуемое число проходов и тип действия
(операции) после выполнения условий и заданного числа ее проходов.
После того, как ,после запуска программы, данная контрольная точка
пройдена требуемое число раз, знак ">" после буквы "C" исчезает.
    Во  второй колонке, колонке полей "Occur", отображается  число
фактических  проходов  данной  контрольной  точки  при  выполнении
программы до ее останова. Состояние счетчика числа проходов  может
быть  сброшено  в  нулевое состояние нажатием клавиши  F10  (Clear
OCC), после чего контрольная точка активизируется снова.

    При использовании опции "BRK Menu" приобретают новые назначения и
функциональные клавиши, а именно:
    F1  -  View Trace - просмотр трассы. При нажатии этой клавиши,
на экране дисплея отображается содержимое трассировочного буфера в
полном обьеме.
    F3  -  Read  Setup   - чтение установки. При  нажатии  клавиши
происходит  чтение из специальной буферной памяти карты  состояния
контрольных точек, введенной перед этим при помощи клавиши  F7,  и
вывод ее на экран дисплея.
    F4  - Help ON - помощь. При нажатии клавиши на экран выводятся
краткие  пояснения к позициям курсора на карте задания контрольных
точек.
    F5  -  CMD  line  -  командная  строка.  При  нажатии  клавиши
осуществляется  обратный перевод курсора в поле командной  строки.
При  этом  изображение таблицы задания контрольных точек с  экрана
убирается.
    F7  -  Save Setup - сохранение установки. При нажатии  клавиши
происходит  перезапись (копирование) таблицы состояния контрольных
точек в специальную буферную память.
    F9  -  Clear  BR - очистка BRK. При нажатии клавиши происходит
стирание  всей,  занесенной  в таблицу задания  контрольных  точек
,информации, т.е. перевод ее в исходное состояние (при  сохранении
ее в буферной памяти).
    F10   -  Clear  OCC  -  очистка  Occur.  При  нажатии  клавиши
происходит  сброс  в  исходное нулевое  состояние  счетчика  числа
проходов контрольных точек "Occur".

          Раздел  III.  Трассировка и просмотр ее следа.

    Трассировкой программ называется запоминание в специальной трассировочной
буферной  памяти всех выполненных  команд вместе с их адресами,  а
также,  как  правило,  соответствующие состояния  всех  программно
доступных  регистров  и  вершины  стека  Вся  эта  зафиксированная
информация о ходе выполнения отлаживаемой программы носит название
следа трассировки программы.
    Трассировка отлаживаемой программы в отладчике AFDPror, может быть задана
несколькими способами.
    1.  При  запуске  программы на исполнение  директивой  "GC"  с
ключом   "/T".   В  этом  случае,  трассировка  осуществляется   с
начального  адреса, указанного в этой директиве, и  независимо  от
разрешения  или запрещения трассировки директивой "TR  ON!OFF",  а
также наличия и места расположения операции разрешения трассировки
"T ON" в поле "Action" таблицы задания контрольных точек.
    Окончание трассировки, при этом, будет либо при  остановке программы по
конечному адресу, указанному в директиве "GC" (останов по  "BR0"),
либо  при  останове  исполнения программы на контрольной  точке  с
операцией  "Break" в поле "Action", либо, наконец,  по  достижении
контрольной точки с операцией "T OFF" в этом же поле. В  последних
двух  случаях, конечно, следует иметь в виду, что при  последующих
запусках  по  директиве "GC", счетчики числа фактических  проходов
"Occur" предварительно не сбрасываются.
    2,  При запуске программы на исполнение директивой "G". В этом
случае  трассировка осуществляется также независимо от  разрешения
или   запрещения   трассировки  директивой  "TR  ON!OFF",   однако
начинается  она  только  после  достижения  контрольной  точки   с
операцией  "T ON" в поле действий "Action". Окончание  трассировки
происходит аналогично тому, как  это происходит и в случае запуска
программы по директиве "GC".
    3.   Трассировка  может осуществлятся также  и  при  пошаговом
(покомандном) исполнении отлаживаемой программы, однако для  этого
необходимо  предварительно  разрешить трассировку  директивой  "TR
ON".

    Просмотр следа трассировки, фиксируемого в специальном трассировочном
буфере  обьемом  в  100  записей  (соответствуюшем  хранению   100
выполненных   команд   с  содержимым  всех  программно   доступных
регистров  и  вершины стека к моменту выполнения  каждой  команды)
,.&%b осуществляться в трех вариантах:
    1.   В виде последовательности только выполненных команд в  их
ассемблерном   и   кодовом  (шестнадцатиразрядном)  представлении,
вместе  с  адресами,  заданными  смещениями  в  кодовом  сегменте.
Просмотр   осуществляется  непосредственно  в  поле   отлаживаемой
программы (поле дизассемблирования), одновременно по 9 команд (см.
Рис  3).  Этот просмотр осуществляется после задания директивы "T"
в  командной  строке. Выход из просмотра происходит после  нажатия
клавиши "Enter".
    2,  Также только в виде последовательности выполненных команд,
но  на  полном экране дисплея, одновременно по (до) 21  команде  в
ассемблерном   и   кодовом  представлении,  с  полными   адресами,
заданными  с указанием базового адреса сегмента и смещения  в  нем
(см.  Рис  4). Этот просмотр осуществляется при задании  директивы
"TB  /S" в командной строке. Выход из просмотра - также по клавише
"Enter".
    3.  На  полном  экране дисплея по 5 записей одновременно.  При
этом  каждая  запись  включает  в  себя:  выполненную  команду   в
ассемблерном  представлении,  адресное  смещение  этой  команды  в
кодовом  сегменте,  а  также состояние всех  программно  доступных
регистров и вершину стека из 8 байт, соответсвующих моменту начала
выполнения   данной   команды   (см.   Рис   5).   Этот   просмотр
осуществляется  либо заданием директивы "TB" в  командной  строке,
либо  из  меню  "BRK  Menu"  (режима задания  контрольных  точек),
нажатием функциональной клавиши F1.
    Передвижение окна просмотра содержимого буферной памяти трассировки во
всех  трех  вариантах осуществляется при помощи клавиш стрелок,  а
также  клавиш  "Page Up" и "Page Down". Выход из  просмотра  -  по
клавише "Enter".
    Сброс следа трассировки, т.е. очищение трассировочного буфера,
производиться директивой "TR CLR".
    При просмотре следа трассировки следует учитывать, что заполнение
трассировочного буфера осуществляется по принципу FIFO, т.е. после
полного  заполнения  буферной  памяти,  первые  введенные   записи
последовательно выталкиваются из буфера и пропадают.























                                         СОДЕРЖАНИЕ

    Стр.
    ВВЕДЕНИЕ
..................................................................
.........................  3


    Раздел I.  Исходные поля отображения на экране дисплея .............
5


        1.  Поле  программно доступных регистров и  вершины  стека
......  5
        2. Поле отлаживаемой программы (поле дизассемблирования) .
16
                 3.           Поля          дампов          памяти
..................................................................
.... 18
         4.   Поле  подсказки  назначения  функциональных   клавиш
............  19
                5.          Поле         командной          строки
................................................................
19
    Раздел       II.       Управление      работой       отладчика
........................................  19
             1.       Назначение       функциональных       клавиш
........................................  19
           2.     Назначение     директив     командной     строки
...................................   21
    Раздел         III.        Работа        с        контрольными
точками......................................  41
    Раздел IV. Трассировка программы и просмотр ее следа ...............
45
    Содержание
..................................................................
.........................   52
